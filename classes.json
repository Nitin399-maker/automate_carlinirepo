{
    "Env": "class Env:\n    docker = None\n    fake_docker_id = None\n    container = None\n    docker_job = None",
    "Reason": "class Reason:\n    def __init__(self, node, children):\n        self.node = node\n        self.children = children\n\n    def __repr__(self):\n        return repr((self.node, self.children))",
    "Node": "class Node:\n\n    def __init__(self, runner):\n        self.runner = runner\n    \n    def setup(self, env, conv, llm, eval_llm, vision_eval_llm):\n        self.env = env\n        self.conv = conv\n        self.llm = llm\n        self.eval_llm = eval_llm\n        self.vision_eval_llm = vision_eval_llm\n\n    def __call__(self, orig_output=\"\"):\n        raise NotImplementedError()\n        \n    def __rshift__(self, other_node):\n        if isinstance(other_node, str):\n            other_node = StringNode(other_node)\n        return ThenNode(self, other_node)\n    \n    def __rrshift__(self, other_node):\n        if isinstance(other_node, str):\n            other_node = StringNode(other_node)\n        return ThenNode(other_node, self)\n    \n    def __and__(self, other_node):\n        return AndNode(self, other_node)\n\n    def __or__(self, other_node):\n        return OrNode(self, other_node)\n\n    def __invert__(self):\n        return NotNode(self)",
    "StringNode": "class StringNode(Node):\n    def __init__(self, string):\n        self.string = string\n\n    def __call__(self, orig_output=\"\"):\n        yield self.string, Reason(type(self), self.string)",
    "ThenNode": "class ThenNode(Node):\n    def __init__(self, node1, node2):\n        self.node1 = node1\n        self.node2 = node2\n\n    def setup(self, env, conv, llm, eval_llm, vision_eval_llm):\n        super().setup(env, conv, llm, eval_llm, vision_eval_llm)\n        self.node1.setup(env, conv, llm, eval_llm, vision_eval_llm)\n        self.node2.setup(env=env, conv=conv, llm=llm, eval_llm=eval_llm, vision_eval_llm=vision_eval_llm)\n\n    def __call__(self, orig_output=None):\n        for output1, response1 in self.node1(orig_output):\n            for output2, response2 in self.node2(output1):\n                yield output2, Reason(type(self), (response1, response2))",
    "AndNode": "class AndNode(ThenNode):\n    def __init__(self, node1, node2):\n        self.node1 = node1\n        self.node2 = node2\n\n    def __call__(self, orig_output):\n        for output1, txt1 in self.node1(orig_output):\n            for output2, txt2 in self.node2(orig_output):\n                yield output1 and output2, Reason(type(self), (txt1, txt2, output1 and output2))",
    "OrNode": "class OrNode(ThenNode):\n    def __init__(self, node1, node2):\n        self.node1 = node1\n        self.node2 = node2\n\n    def __call__(self, orig_output):\n        for output1, txt1 in self.node1(orig_output):\n            for output2, txt2 in self.node2(orig_output):\n                yield output1 or output2, Reason(type(self), (txt1, txt2, output1 or output2))",
    "NotNode": "class NotNode(Node):\n    def __init__(self, node1):\n        self.node1 = node1\n\n    def setup(self, env, conv, llm, eval_llm, vision_eval_llm):\n        super().setup(env, conv, llm, eval_llm, vision_eval_llm)\n        self.node1.setup(env, conv, llm, eval_llm, vision_eval_llm)\n        \n    def __call__(self, orig_output):\n        for output1, txt1 in self.node1(orig_output):\n            yield not output1, Reason(type(self), [txt1, not output1])",
    "PyFunc": "class PyFunc(Node):\n    def __call__(self, x):\n        try:\n            out = self.runner(x)\n            if type(out) == tuple:\n                ok, log = out\n                return [(ok, Reason(type(self), (log, ok)))]\n            else:\n                return [(out, Reason(type(self), (\"\", out)))]\n        except:\n            return [(\"\", Reason(type(self), [\"Error\", False]))]",
    "Echo": "class Echo(Node):\n    def __init__(self):\n        pass\n\n    def __call__(self, x):\n        print('ECHOING:', x)\n        yield x, Reason(type(self), None)",
    "Setup": "class Setup(Node):\n    def __call__(self, x):\n        docker_controller.setup_docker(self.env)\n        code = inspect.getsource(self.runner)\n        to_invoke = self.runner.__name__\n\n        code = code + f\"\\n\\n{to_invoke}()\"\n        out = invoke_docker(self.env, {\"setup.py\": code.encode()}, [PYTHON_ENV, \"setup.py\"])\n\n        return [(out, Reason(type(self), None))]",
    "PyEvaluator": "class PyEvaluator(Node):\n    def __call__(self, x):\n        code = inspect.getsource(self.runner)\n        to_invoke = self.runner.__name__\n\n        code = code + f\"\\n\\nprint('final: ' + str({to_invoke}()))\"\n        out = invoke_docker(self.env, {\"check.py\": code.encode()}, [PYTHON_ENV, \"check.py\"])\n\n        return [(\"final: True\" in out, Reason(type(self), [out, \"final: True\" in out]))]",
    "SubstringEvaluator": "class SubstringEvaluator(Node):\n    def __init__(self, substr, lower=False):\n        self.substr = substr\n        self.lower = lower\n\n    def __call__(self, output):\n        if self.lower:\n            cond = self.substr.lower() in output.lower()\n        else:\n            cond = self.substr in output\n            \n        if cond:\n            yield True, Reason(type(self), [self.substr, True])\n        else:\n            yield False, Reason(type(self), [self.substr, False])",
    "RegexEvaluator": "class RegexEvaluator(Node):\n\n    def __init__(self, pattern, ignore_case=False):\n        self.pattern = pattern\n        self.ignore_case = ignore_case\n\n    def __call__(self, output):\n        import re\n\n        flags = re.IGNORECASE if self.ignore_case else 0\n        match = re.search(self.pattern, output, flags)\n\n        if match:\n            yield True, Reason(type(self), [self.pattern, True])\n        else:\n            yield False, Reason(type(self), [self.pattern, False])",
    "ContainsIntEvaluator": "class ContainsIntEvaluator(Node):\n    def __init__(self, num):\n        self.num = num\n\n    def __call__(self, output):\n        all_integers = re.findall(r'-?[\\d,]*\\d+\\.?\\d*', output)\n        all_integers = [x.replace(\",\", \"\") for x in all_integers]\n        if str(self.num) in all_integers:\n            yield True, Reason(type(self), [self.num, True])\n        else:\n            yield False, Reason(type(self), [self.num, False])",
    "EqualEvaluator": "class EqualEvaluator(Node):\n    def __init__(self, goal):\n        self.goal = goal\n\n    def __call__(self, output):\n        if self.goal == output:\n            yield True, Reason(type(self), [self.goal, True])\n        else:\n            yield False, Reason(type(self), [self.goal, False])",
    "UntilDone": "class UntilDone(Node):\n    def __init__(self, cond, body, max_iters=100):\n        self.cond = cond\n        self.body = body\n        self.max_iters = max_iters\n        \n    def setup(self, env, conv, llm, eval_llm, vision_eval_llm):\n        super().setup(env, conv, llm, eval_llm, vision_eval_llm)\n        self.cond.setup(env, conv, llm, eval_llm, vision_eval_llm)\n        self.body.setup(env, conv, llm, eval_llm, vision_eval_llm)\n\n    def __call__(self, orig_output=None):\n        log = []\n        for i in range(self.max_iters):\n            for output, txt in self.cond(orig_output):\n                if output:\n                    yield orig_output, Reason(type(self), log)\n                    return\n            orig_output, partial = next(self.body(orig_output))\n            log.append(partial)\n        yield orig_output, Reason(type(self), log)",
    "ExtractJSON": "class ExtractJSON(Node):\n    def __init__(self):\n        pass\n\n    def try_extract(self, output):\n        output = output.replace(\"```json\", \"```\")\n        if \"```\" in output:\n            yield output.split(\"```\")[1]\n            out1 = \"\\n\".join(output.split(\"```\")[1::2])\n            yield out1\n        else:\n            yield output\n        \n    def __call__(self, orig_output):\n        if orig_output.count(\"```\") == 2:\n            for maybe in self.try_extract(orig_output):\n                yield maybe, Reason(type(self), [maybe])\n        else:\n            output = self.llm(\"Take the below answer to my question asking for a JSON output and just return the JSON object directly, with no other description, so I can copy it into an editor directly:\\n\" + orig_output)\n            for maybe in self.try_extract(output):\n                yield maybe, Reason(type(self), [maybe])",
    "ExtractCode": "class ExtractCode(Node):\n    def __init__(self, keep_main=False, postfix=\"\", manual=None, lang=None):\n        self.keep_main = keep_main\n        self.postfix = postfix\n        self.manual = manual\n        self.lang = lang\n\n    def try_extract(self, output):\n        output = re.sub('```[a-z]*', '```', output)\n        if \"```\" in output:\n            ans = output.split(\"```\")[1] + \"\\n\" + self.postfix\n        else:\n            ans = output + \"\\n\" + self.postfix\n        yield ans\n        \n    def __call__(self, orig_output):\n        if orig_output.count(\"```\") == 2:\n            for maybe in self.try_extract(orig_output):\n                yield maybe, Reason(type(self), maybe)\n            return\n\n        language = \"\"\n        if self.lang is not None:\n            language = f\"(in {self.lang})\"\n                \n        if self.manual is not None:\n            output = self.llm(self.manual.replace(\"<A>\", orig_output))\n        elif self.keep_main:\n            assert self.postfix == \"\"\n            output = self.llm(f\"Take the below answer to my programming question {language} and return just the complete code in a single file so I can copy and paste it into an editor and directly run it. Include any header and main necessary so I can run it by copying this one file. DO NOT MODIFY THE CODE OR WRITE NEW CODE. Here is the code: \\n\" + orig_output)\n        else:\n            output = self.llm(f\"Take the below answer to my programming question {language} and return just the complete code in a single file so I can copy and paste it into an editor and directly run it. Remove any test cases or example code after the function definition. Remove any main function. I will write those myself. Do include header imports. DO NOT MODIFY THE CODE OR WRITE NEW CODE. Here is the code: \\n\" + orig_output + (\"\\nI will be running this code with the following helper functions:\\n\" + self.postfix if self.postfix else \"\"))\n\n        for maybe in self.try_extract(output):\n            yield maybe, Reason(type(self), maybe)",
    "MakeFile": "class MakeFile(Node):\n    def __init__(self, name):\n        self.name = name\n\n    def __call__(self, code):\n        out = invoke_docker(self.env, {self.name: code.encode()}, [\"echo\"])\n        yield out, Reason(type(self), (code, out))",
    "MakeFilesFromJSON": "class MakeFilesFromJSON(Node):\n    def __init__(self):\n        pass\n\n    def __call__(self, json_str):\n        try:\n            json_obj = json.loads(json_str)\n        except:\n            json_obj = {}\n            \n        for k in json_obj.keys():\n            if not isinstance(json_obj[k], bytes):\n                json_obj[k] = json_obj[k].encode()\n\n        out = invoke_docker(self.env, json_obj, [\"echo\"])\n        yield out, Reason(type(self), (json_str, out))",
    "PythonRun": "class PythonRun(Node):\n    def __init__(self, test_case=\"\", out_bytes=False):\n        self.test_case = test_case\n        self.out_bytes = out_bytes\n\n    def __call__(self, code):\n        code = code + \"\\n\\n\" + self.test_case\n\n        out = invoke_docker(self.env, {\"main.py\": code.encode()}, [PYTHON_ENV, \"main.py\"], out_bytes=self.out_bytes)\n        yield out, Reason(type(self), (code, out))",
    "SQLRun": "class SQLRun(Node):\n    def __init__(self):\n        pass\n\n    def __call__(self, code):\n        out = invoke_docker(self.env, {\"run.sql\": code.encode()}, [\"sqlite3\", \"-init\", \"run.sql\", \"database.db\", \".exit\"])\n        yield out, Reason(type(self), (code, out))",
    "BashRun": "class BashRun(Node):\n    def __init__(self, test_case=\"\", args=[]):\n        self.test_case = test_case\n        self.args = args\n\n    def __call__(self, code):\n        code = code + \"\\n\\n\" + self.test_case\n\n        out = invoke_docker(self.env, {\"main.sh\": code.encode()}, [\"bash\", \"main.sh\", *self.args])\n        yield out, Reason(type(self), (code, out))",
    "TerminalRun": "class TerminalRun(Node):\n    def __init__(self):\n        return\n\n    def __call__(self, code):\n        if code:\n            out = invoke_docker(self.env, {\"main.sh\": code.encode()}, [\"bash\", \"main.sh\"])\n        else:\n            out = \"\"\n        yield out, Reason(type(self), (code, out))",
    "RustRun": "class RustRun(Node):\n    def __init__(self, test_case=\"\"):\n        self.test_case = test_case\n\n    def __call__(self, code):\n        if 'fn main' in code and 'fn main' in self.test_case:\n            code = code.replace('fn main', 'fn __delete_this__main')\n\n        code = code + \"\\n\\n\" + self.test_case\n            \n        out = invoke_docker(self.env, {\"main.rs\": code.encode(),\n                                       \"main.sh\": \"rustc -o a.out main.rs\\n./a.out\".encode()},\n                            [\"bash\", \"main.sh\"])\n        yield out, Reason(type(self), (code, out))",
    "CRun": "class CRun(Node):\n    def __init__(self, test_case=\"\", out_bytes=False, gccflags=\"\", argv=\"\"):\n        self.test_case = test_case\n        self.out_bytes = out_bytes\n        self.gccflags = gccflags\n        self.argv = argv\n\n    def __call__(self, code):\n        if 'int main' in code and 'int main' in self.test_case:\n            code = code.replace('int main', 'int __delete_this__main')\n\n        code = code + \"\\n\\n\" + self.test_case\n        \n        out = invoke_docker(self.env, {\"main.c\": code.encode(),\n                                       \"main.sh\": f\"gcc -o a.out main.c -lm {self.gccflags}\\n./a.out {self.argv}\".encode()},\n                            [\"bash\", \"main.sh\"], out_bytes=self.out_bytes)\n        yield out, Reason(type(self), (code, out))",
    "CppRun": "class CppRun(Node):\n    def __init__(self, test_case=\"\", out_bytes=False):\n        self.test_case = test_case\n        self.out_bytes = out_bytes\n\n    def __call__(self, code):\n        if 'int main' in code and 'int main' in self.test_case:\n            code = code.replace('int main', 'int __delete_this__main')\n\n        code = code + \"\\n\\n\" + self.test_case\n        \n        out = invoke_docker(self.env, {\"main.cpp\": code.encode(),\n                                       \"main.sh\": \"g++ -o a.out main.cpp -lm\\n./a.out\".encode()},\n                            [\"bash\", \"main.sh\"], out_bytes=self.out_bytes)\n        yield out, Reason(type(self), (code, out))",
    "StartDockerJob": "class StartDockerJob(Node):\n    def __init__(self, command, eos_string):\n        self.command = command\n        self.eos_string = eos_string\n\n    def __call__(self, text):\n        self.env.docker_job = DockerJob(self.env.container.id if 'id' in dir(self.env.container) else self.env.container, self.eos_string)\n        out = self.env.docker_job(self.command)\n\n        yield out, Reason(type(self), (text, out))",
    "SendStdoutReceiveStdin": "class SendStdoutReceiveStdin(Node):\n    def __init__(self):\n        pass\n\n    def __call__(self, text):\n        out = self.env.docker_job(text)\n        yield out, Reason(type(self), (out,))",
    "LLMConversation": "class LLMConversation(Node):\n    def __init__(self, check_prompt=\"<A>\"):\n        self.check_prompt = check_prompt\n\n    def __call__(self, output):\n        to_send = self.check_prompt.replace(\"<A>\", output)\n        out = self.conv(to_send)\n        yield out, Reason(type(self), (to_send, out))",
    "SeleniumDraw": "class SeleniumDraw(Node):\n    def __init__(self):\n        pass\n\n    def __call__(self, code):\n        try:\n        #if 1:\n            from selenium import webdriver\n            from selenium.webdriver.chrome.options import Options\n            \n            chrome_options = Options()\n            #chrome_options.add_argument(\"--headless\")\n            chrome_options.add_argument(\"--no-sandbox\")\n            chrome_options.add_argument(\"--disable-dev-shm-usage\")\n    \n            r = random.randint(0, 1000000)\n            \n            open(\"/tmp/a%r.html\"%r, \"w\").write(code)\n    \n            url = 'file:///tmp/a%d.html'%r\n    \n            browser = webdriver.Chrome(options=chrome_options)\n            browser.get(url)\n    \n            time.sleep(2)\n    \n            screenshot_path = '/tmp/a%d.png'%r\n            browser.save_screenshot(screenshot_path)\n    \n            browser.quit()\n    \n            time.sleep(1)\n    \n            img = Image.open(screenshot_path).convert('RGB')\n    \n            # get png data\n            img_data = io.BytesIO()\n            img.save(img_data, format=\"PNG\")\n            img_data.seek(0)\n            img_data = img_data.read()\n            \n            \n            yield img_data, Reason(type(self), img_data)\n\n        #try:\n            pass\n    \n        except:\n            yield b\"\", Reason(type(self), b\"\")",
    "JSONSubsetEvaluator": "class JSONSubsetEvaluator(Node):\n    def __init__(self, goal):\n        self.goal = goal\n        \n    def check(self, goal, output):\n        if isinstance(goal, dict) and isinstance(output, dict):\n            # Iterate over all key-value pairs in the goal dictionary\n            for key, value in goal.items():\n                # Check if the key is present in the output\n                if key not in output:\n                    return False\n                # If the value is a dict or list, recursively check\n                if isinstance(value, (dict, list)):\n                    if not self.check(value, output[key]):\n                        return False\n                # Otherwise, check if the value matches\n                elif output[key] != value:\n                    return False\n        elif isinstance(goal, list) and isinstance(output, list):\n            # Check each element in the goal list\n            for item in goal:\n                if item not in output:\n                    return False, Reason(self, [\"Item not present\", item])\n        else:\n            # Not a dict or list, so check if the values are equal\n            if goal == output:\n                return True\n            else:\n                return False\n    \n        # todo better error message\n        return True\n        \n    def __call__(self, output):\n        try:\n            output = json.loads(output)\n        except:\n            yield False, Reason(type(self), [self.goal, False])\n            return\n\n        ok = self.check(self.goal, output)\n        yield ok, Reason(type(self), [self.goal, ok])",
    "LLMVisionRun": "class LLMVisionRun(Node):\n    def __init__(self, check_prompt=\"<A>\", llm=VISION_EVAL_LLM):\n        self.check_prompt = check_prompt\n        self.which_llm = llm\n\n    def __call__(self, output):\n        llm = getattr(self, self.which_llm)\n        try:\n            if isinstance(output, bytes):\n                img = Image.open(io.BytesIO(output))\n            else:\n                img = output\n            out = llm(self.check_prompt, add_image=img, max_tokens=512)\n        except Exception as e:\n            out = str(e)\n        yield out, Reason(type(self), (self.check_prompt, out))",
    "Conversation": "class Conversation:\n    def __init__(self, llm,preample = ''):\n        self.llm = llm\n        self.history = []\n        self.preample = preample\n\n    def __call__(self, msg):\n        if len(self.history)==0:\n            msg = self.preample + msg        \n        self.history.append(msg)\n        output = self.llm(self.history)\n        self.history.append(output)\n        return output\n\n    def __repr__(self):\n        return \"Conversation(\" + repr(self.history) + \")\""
}